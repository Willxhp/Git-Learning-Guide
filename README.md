### 版本控制系统分类

1. 集中式版本控制系统（SVN）

   代码存放在单一的服务器上，便于项目的管理，但是当服务器故障后，整个项目的历史记录都会丢失。SVN存放的是版本之间的差异，需要的硬盘空间较小，但是版本回滚速度很慢。

2. 分布式版本控制系统（Git)

   客户端并不只是提取最新版本的文件快照，而是把代码仓库完整的镜像下来。分布式版本控制系统在管理项目时，存放的不是项目版本与版本之间的差异，它存放的是索引，需要的硬盘空间会相对大一些，但是版本回滚速度很快。

### Git初始化配置

git bash中运行的是Linux命令。

```powershell
git --version # 查看git版本
git config --list # 检查已有的配置信息
git config --global user.name "Willxhp"
git config --global user.email Willxhp@163.com
# 配置优先级
--system # 系统中对所有用户都普遍适用的配置
--global # 配置文件只适用于当前用户
# 如果两项都不写，则配置只针对当前项目有效，每一个级别的配置会覆盖上层的相同配置
git config --global --unset user.name # 删除配置
```

### Git底层命令

#### 初始化仓库

Git区域：工作区、暂存区和版本库

```powershell
git init # 初始化仓库
.gitignore # git忽略文件
# .git文件夹中各目录的作用
hooks # 包含客户端或服务端的钩子脚本，即可以编辑在Git特定时间节点需要触发的回调函数
info # 包含一个全局性的排除文件
logs # 保存日志信息
objects # 存储所有的数据内容
refs # 存储分支所指向的g提交对象的指针
config # 包含项目特有的配置选选项
description # 显示对仓库的描述
HEAD # 指示目前HEAD所指向echo的分支
index # 保存暂存区的信息
```

#### 基本Linux命令

```powershell
clear # 清除屏幕
cd # 进入目录
echo 'text' # 向控制台输出信息，类似JS中的console.log
echo 'text' > file.text # 新建文件并向其中输入信息
ll # 将当前目录下的子文件和子目录输出在控制台
find 目录名 # 将对应目录下的子孙文件和子孙目录输出在控制台
find 目录名 -type f # 将对应目录下的文件输出再控制台（不包括目录）
rm 文件名 # 删除文件
mv 文件名 新名称 # 重命名文件
cat 文件的url # 查看对应的文件内容
vim 文件的url # 会进入vim编辑器
	i # 进入插入模式，进行文件的编辑
	esc # 退出插入模式
	: # 进行命令的执行
		q! # 强制退出不保存
		wq # 保存退出
		set nu # 设置行号
```

#### git对象

Git的核心部分是一个简单的键值对数据库，可以向该数据库中插入任意类型的内容，该数据库会返回对应的键值（hash值），通过该键值可以再次检索该内容。

```powershell
echo 'text' | git hash-object -w --stdin
# git hash-object 将内容转换为键值，-W选项命令存储数据对象到.git文件夹中的objects文件夹中，若不指示该选项，则命令仅返回键值而不进行存储，--stdin选项则指示该命令从标准输入读取内容，即需要与echo配合使用，若不指定则需要在命令尾部给出待存储文件的路径
git hash-object -w 文件路径
git hash-object 文件路径 # 仅返回键值，不进行存储
# 在数据库中存储的文件均经过压缩，直接打开会显示乱码
git cat-file -p 哈希值 # 以正常格式显示存储的内容
git cat-file -t 哈希值 # 返回文件存储的对象格式，blob，所有的git对象均为blob类型的对象
```

每个git对象只能代表一个文件的一个版本，不能代表项目的一个版本，而且还存在以下问题：

1. 记住文件的每一个版本所对应的hash值并不现实
2. 仅保存了文件的内容，而文件名并没有被保存
3. 以上的所有操作都是在对本地数据库进行操作，不涉及暂存区

#### 树对象

树对象可以解决文件名保存的问题，可以将多个文件组织到一起，一个树对象也可以包含另一个树对象。Git以一种类似于UNIX文件系统的方式存储内容，所有内容均以树对象和git对象的形式存储，其中树对象对应了UNIX中的目录项，git对象则大致上对应文件内容。

```powershell
git update-index --add --cacheinfo 文件模式 数据对象哈希值 文件名 # 将文件的某个版本存入暂存区，并给文件内容命名
# --add 如果此前该文件不在暂存区中，需使用该命令选项 --cacheinfo 因为要添加的文件位于Git数据库中，而不是在当前目录下，所以需要使用该命令选项，文件模式包含：100644普通文件，100755可执行文件，120000符号链接
git update-index --add 文件名 # 该命令相当于两步操作的合并，即首先为文件生成git对象，并将其存入暂存区
git cat-file -t 树对象哈希值 # 返回tree
git cat-file -p 树对象哈希值 # 查看树对象
git ls-files -s # 查看暂存区的内容
git write-tree # 将暂存区中的内容存储至数据库中，并返回树对象的哈希值，该操作并不会清空暂存区
git read-tree --prefix=bak 树对象哈希值 # 读取一个树对象，并将其放入暂存区，可以让一个树对象放入另一个树对象中，形成新的树对象
```

一个树对象即代表了项目的一个版本，但是若想重用这些快照，则必须记住树对象的哈希值，而且无法保存一些版本的相关信息。

#### 提交对象

提交对象即在树对象的基础上进行了一次包装，使每个对象都含有版本提交的所有信息。

```powershell
echo 'first commit' | git commit-tree 树对象的哈希值 # 将树对象包装成为一个提交对象，返回该提交对象的哈希值
echo 'second commit' | git commit-tree 树对象的哈希值 -p 父提交对象哈希值 # 如果是第二次提交，则还需要指定该提交对象的父对象，使其成为链式
git cat-file -t 提交对象的哈希值 # 返回commit
# git-commit命令会将提交对象直接存储至数据库中
```

### Git高层命令

#### Git本地操作

```powershell
git add 目录/文件名/. # 将修改添加到暂存区，如果后面是目录，则会递归添加所有的子目录
	# 相当于执行以下两个底层命令，先生成git对象存储到数据库中，再将git对象放入暂存区
	git hash-object -w 文件名 # 修改了多少个工作目录中的文件，此命令就被执行多少次
	git update-index --add --cacheinfo 数据对象哈希值
git commit -m "注释内容" # 将暂存区提交到版本库
	# 相当于执行以下两个底层命令，会将暂存区中的内容以树对象的形式存储至数据库中，同时再将树对象生成提交对象存储至数据库
	git write-tree
	git commit-tree
git commit # 进入vim编辑器，可以编辑大量的注释内容
git commit -a # 跳过暂存区，直接将所有的已跟踪的文件进行提交
```

工作目录下面的所有文件只存在两种状态：已跟踪和未跟踪。已跟踪的文件时指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是已提交、已修改或已暂存。

```powershell
git status # 查看文件状态
git diff # 查看做的哪些更新还没有暂存
git diff --cached 或 git diff --staged # 查看有哪些更新暂存了但是还没有提交
git log # 查看提交日志，信息较为详细
git log --pretty=oneline # 将每次提交的信息调整为一行显示
git log --oneline # 将每次提交的信息调整为一行显示，提交对象的哈希值只取前几位
git reflog # 查看提交最完整的日志，包括撤回的提交、删除的分支等
git rm 文件名 # 删除工作目录中对应的文件，再将修改添加到暂存区
	# 相当于执行以下命令
	rm 文件名
	git add .
git mv 文件名 新文件名 # 重命名工作目录中的文件，再将修改添加到暂存区
```

在Git中，如果删除了某个文件或重命名某个文件，并不会删除版本库中该文件所对应的git对象，在提交后会在版本库中生成一个新的树对象和一个提交对象，只不过这个树对象中不再包含该文件的git对象。git 

#### Git分支操作

Git中的分支可以理解为指向最新版本提交对象的一个可移动的指针。HEAD就是一个指针，默认指向master分支，在切换分支时就是让HEAD指向不同的分支。每次有新提交的时候，HEAD都会带着当前指向的分支一起向前移动。

```powershell
git branch # 显示分支列表
git branch 分支名 # 创建分支，在当前所在的提交对象上创建一个新的指针
git checkout 分支名 # 切换分支
git branch -d 分支名 # 删除分支，分支需要合并到主分支，不能删除当前所在的分支
git branch -D 分支名 # 强制删除分支，分支不需要合并到主分支
git branch -v # 查看每一个分支所对应的提交对象
git branch -m 分支名 新名称 # 重命名分支
git branch 分支名 提交对象哈希值 # 在指定的提交对象创建分支
git branch --merged # 查看哪些分支已经合并到当前分支，列表中带有*号表明已经合并
git branch --no-merged # 查看还有哪些分支未合并到当前分支
git log --oneline --decorate --graph --all # 查看项目完整的分叉历史，即所有的分支
# 上面的命令过长，可以使用配别名的方法为命名设置别名，如果命令只有一个单词，则不需要加双引号
git config --global alias.xhp "log --oneline --decorate --graph --all"
git checkout -b 分支名 # 创建新分支并切换到该分支
git merge 分支名 # 合并分支
```

分支合并可分为快进合并和典型合并，快进合并不会导致冲突，而典型合并则会导致冲突，需要手动解决冲突。手动接触冲突后执行`git add 文件名`标记冲突已经解决。分支模式可以分为长期分支和特性分支，修改代码一般在特性分支上进行。

切换分支会修改HEAD、暂存区和工作目录。最佳实践：每次切换分支前，当前分支一定是已提交的状态。在切换分支时，如果当前分支上有未跟踪的文件或有未曾提交过的暂存（文件刚被跟踪，还未进行提交），分支可以切换成功，但是对当前分支所做的修改或暂存会全部转移到切换后的分支中，污染其他分支。除以上情况外，如果当前分支存在未暂存的修改或未提交的暂存，则无法切换分支。

#### Git存储

```powershell
# 在切换分支时，若遇到当前分支内容尚未开发完成，不能进行提交，可以使用git缓存命令将工作区和暂存区的内容缓存，注意：该方法无法缓存未追踪的文件，一般来说，在使用以下命令之前先运行git add .
git stash # 缓存当前工作区和暂存区中的状态至git栈中，可以多次执行
git stash pop # 恢复最新的存储到工作区，并将其从栈中删除，git默认会把工作区和暂存区的改动都恢复到工作区
git stash apply # 恢复最新的存储到工作区，但是不删除
git stash list # 查看stash记录
git stash pop stash@{0} # 恢复指定的存储到工作区，同时将其删除，编号从0开始，0是栈顶元素
git stash apply stash@{0} # 恢复指定的存储到工作区，不删除存储
git stash drop stash@{0} # 删除栈中指定的存储
```

#### Git撤销与重置

```powershell
# 撤销修改
git restore 文件名 # 撤回在工作区中的修改（文件已跟踪），以暂存区为准，旧版本为git checkout --文件名 
git restore --staged 文件名 # 撤回暂存区中的修改，以版本库为准，旧版本中为git reset [--mixed] [HEAD] 文件名
git commit --amend # 修改上一次的提交内容，可以修改注释信息，同时将上一次提交的内容修改为当前暂存区的内容
# 重置reset，用于撤销错误的提交，会将HEAD和HEAD所在的分支一并重置到指定的提交对象，HEAD~表示HEAD的上一个提交对象
git reset --soft 提交对象哈希值 # 重置HEAD和分支的同时，保留工作目录和暂存区中的内容，并把重置HEAD所带来的差异放进暂存区
git reset [--mixed] 提交对象哈希值 # 默认值，只会保留工作目录中的内容，会将暂存区中的内容也进行重置
git reset --hard 提交对象哈希值 #  重置HEAD和分支的同时，重置工作目录和暂存区中的内容，危险操作！
```

#### Git标签

Git可以给历史中的某一个提交打上标签，一般用于标记项目的版本号。

```powershell
git tag # 列出所有的标签
git tag -l 'v1.8*' # 列出某一系列标签
# Git使用两种主要类型的标签：轻量标签和附注标签，轻量标签很像一个不会改变的分支，只是一个特定提交的引用
git tag 标签名 # 给当前提交对象打tag 
git tag 标签名 提交对象哈希值
git show 标签名 # 查看特定标签（提交对象）
git tag -d 标签名 # 删除特定标签（不会删除提交对象）
# 检出标签
git checkout 标签名 # 此时会出现头部分离的问题，可以通过创建分支解决头部分离问题
git checkout -b 分支名 
```

### 远程仓库Github

#### 团队协作一般步骤

1. 项目经理初始化空的远程仓库。

2. 创建本地仓库

   ```powershell
   git remote add 远程仓库别名 仓库地址（HTTPS/SSH） # 为远程仓库配置别名
   git remote -v # 显示远程仓库使用的别名与其对应的URL
   git remote rename 远程仓库别名 新名称 # 重命名远程仓库
   git remote rm 远程仓库别名 # 移除一个远程仓库
   git init # 初始化本地仓库
   git config user.name / user.email # 项目级别修改配置文件
   git add
   git commit -m ""
   ```

3. 推送本地仓库到远程仓库

   ```powershell
   git push 远程仓库别名 分支名 # 如果仓库地址为HTTPS模式，则需要舒服用户名、密码，此时会自动生成远程跟踪分支
   ```

4. 项目成员克隆远程仓库

   ```powershell
   git clone 仓库地址
   ```

5. 修改源码文件

   ```powershell
   git add .
   git commit
   git push 仓库别名 分支名 # 完整写法git push 远程仓库别名 分支名:远程分支名
   ```

6. 项目经理更新修改

   ```powershell
   git fetch 远程仓库别名 远程分支名 # 将修改同步到远程跟踪分支上
   git fetch 远程仓库别名 # 将远程仓库的所有分支同步到远程跟踪分支上
   git merge 远程跟踪分支名 # 合并远程跟踪分支
   # 如果本地没有该分支，可以在远程跟踪分支上创建一个新的分支
   git checkout -b 本地分支名 远程跟踪分支名
   ```

#### 远程跟踪分支

远程跟踪分支时远程分支状态的引用，是不能移动的本地分支，在做任何网络通信操作的时候，会自动移动。在执行`git push`命令时，会自动生成一个远程跟踪分支，但是该远程跟踪分支并不会被当前本地分支所跟踪。远程跟踪分支`[remote]/[branch]`形式命名，远程跟踪分支会自动与远程分支同步。当克隆一个仓库时，会自动地创建一个跟踪`origin/master`的`master`分支（若该仓库所有分支已经跟踪到远程跟踪分支，则克隆后的仓库的所有分支也会跟踪到对应的远程跟踪分支上）。本地分支需要跟踪远程跟踪分支后，才可以直接使用`git push`和`git pull`。

```powershell
# 本地分支跟踪远程跟踪分支
git checkout -b branch [remote]/[branch] # 在远程跟踪分支上新建一个本地分支并跟踪
git checkout --track [remote]/[branch] # 效果与上方命令相同
git branch -u [remote]/[branch] # (-u是--set-upstream-to的简写) 将当前分支跟踪至指定的远程跟踪分支
git branch -vv # 可以查看设置的所有跟踪分支
git push -u 远程仓库别名 本地分支名 # 在创建远程跟踪分支的同时，将本地分支跟踪到远程跟踪分支
```

#### 冲突解决

在团队开发协作时，可能会在执行`git push`和`git pull`时出现冲突。

当不同开发者在同一个分支对同一个文件做出不同修改后，第二个执行`git push`的开发者会出现无法推送远程仓库的情况，此时需要先执行`git pull`命令拉取最新冲突代码，解决冲突后重新提交，然后再`git push`将代码推送到远程仓库中，此时第一位开发者若执行`git pull`命令可以直接或缺解决冲突后的代码而不会在本地再次产生冲突。

当第一位开发者在某一个分支对某一个文件做出修改后，执行`git push`将其推送至远程仓库，而第二位开发者在同一个分支对同一个文件做出不同修改后，没有将修改进行提交或暂存，而是直接执行`git pull`命令，则会拉取失败，此时需要第二位开发者先对当前文件的修改进行提交或暂存，然后再进行拉取。

#### 删除远程分支

```powershell
git push 远程仓库别名 --delete 远程分支名 # 删除远程分支，同时会删除本地的远程跟踪分支
git remote prune 远程仓库别名 --dry-run # 列出仍在远程跟踪但是远程分支已被删除无用远程跟踪分支
git remote prune 远程仓库别名 # 清除上面命令列出来的远程跟踪分支
```

#### pull request流程

如果想要参与某个开源项目，但是对该项目没有推送权限，可以对这个项目进行`Fork`，将会在自己的GitHub空间中创建一个完全属于自己账户的项目副本，且对其拥有推送权限。在派生项目中，可以将修改推送到项目副本中，并通过创建合并请求（pull request）来让改动进行源版本库。

基本流程：

1. 在自己fork的项目中从master分支中创建一个新分支；
2. 提交一些修改来改进项目；
3. 将这个分支推送到Github上；
4. 创建一个合并请求；
5. 与源码作者讨论，根据实际情况继续修改；
6. 源码作者合并或关闭合并请求。

#### 忽略文件

使用`.gitignore`配置文件列出要忽略文件的匹配模式。采用glob模式（简化的正则表达式）进行文件和文件夹的匹配。

```powershell
# #开头表示注释，/结尾表示目录，/开头表示项目根目录，!表示取反，*匹配零个或多个任意字符，[abc]匹配任何一个在方括号中的字符（里面可以使用短划线如[0-9]），?只匹配一个任意字符，**表示匹配任意中间目录
*.a # 忽略所有的.a文件
!lib.a # 跟踪lib.a文件，即使前面忽略了.a文件
/build # 忽略项目根目录下的build文件夹
build/ # 忽略任何目录下名为build的文件夹
build/*.js # 忽略build文件夹中所有.js文件，但不忽略build文件夹子目录中的.js文件
build/**/*.js # 忽略build文件夹及其子目录下所有的.js文件
```

#### SSH

GitHub上的远程仓库有两种访问方式，分别是HTTPS和SSH，其区别为：HTTPS不需要配置，但是每次访问仓库时需要重复输入GitHub的账号和密码才能访问成功；SSH需要进行额外的配置，但是配置成功后，每次访问仓库时不需要重复输入GitHub的账号和密码。SSH key可以实现本地仓库和GitHub之间免登录的加密数据传输。有两部分组成，`id_rsa`（私钥文件，存放于客户端）和`id_rsa.pub`（公钥文件，配置到GitHub中）。将生成的`id_rsa.pub`文件内容拷贝到GitHub中。

```powershell
# 生成公私钥，在Git Bash中输入以下代码并连按三次回车
ssh-keygen -t rsa -b 4096 -C "邮箱名"
# 生成公私钥的文件位置 C:\Users\Adminstrator\.ssh
# 检查SSH是否配置成功
ssh -T git@github.com
```

